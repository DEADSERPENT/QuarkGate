<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>QuarkGate Performance Benchmark Report</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
            background: #f8fafc; color: #1e293b;
            line-height: 1.6; padding: 2rem;
        }
        .container { max-width: 1200px; margin: 0 auto; }
        h1 { font-size: 2rem; margin-bottom: 0.25rem; color: #0f172a; }
        h2 { font-size: 1.5rem; margin: 2.5rem 0 1rem; color: #1e293b; border-bottom: 2px solid #e2e8f0; padding-bottom: 0.5rem; }
        h3 { font-size: 1.1rem; margin: 1.5rem 0 0.75rem; color: #334155; }
        .subtitle { color: #64748b; margin-bottom: 2rem; font-size: 1.1rem; }
        .timestamp { color: #94a3b8; font-size: 0.85rem; margin-bottom: 2rem; }

        /* Summary cards */
        .summary-grid {
            display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 1.25rem; margin-bottom: 2rem;
        }
        .card {
            background: white; border-radius: 12px; padding: 1.5rem;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1); border: 1px solid #e2e8f0;
        }
        .card-label { font-size: 0.85rem; color: #64748b; text-transform: uppercase; letter-spacing: 0.05em; }
        .card-value { font-size: 2rem; font-weight: 700; margin: 0.25rem 0; }
        .card-detail { font-size: 0.85rem; color: #94a3b8; }
        .card-value.rest { color: #ef4444; }
        .card-value.graphql { color: #3b82f6; }
        .card-value.improvement { color: #10b981; }

        /* Charts */
        .chart-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 1.5rem; margin-bottom: 2rem; }
        .chart-container {
            background: white; border-radius: 12px; padding: 1.5rem;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1); border: 1px solid #e2e8f0;
        }
        .chart-container.full-width { grid-column: 1 / -1; }
        .chart-title { font-size: 1rem; font-weight: 600; margin-bottom: 1rem; color: #334155; }
        canvas { max-height: 400px; }

        /* Tables */
        table { width: 100%; border-collapse: collapse; margin: 1rem 0; }
        th, td { padding: 0.75rem 1rem; text-align: left; border-bottom: 1px solid #e2e8f0; }
        th { background: #f1f5f9; font-weight: 600; font-size: 0.85rem; color: #475569; text-transform: uppercase; letter-spacing: 0.05em; }
        td { font-size: 0.95rem; }
        tr:hover { background: #f8fafc; }
        .val-rest { color: #ef4444; font-weight: 600; }
        .val-gql { color: #3b82f6; font-weight: 600; }
        .val-good { color: #10b981; font-weight: 600; }

        /* Key findings */
        .finding {
            background: #eff6ff; border-left: 4px solid #3b82f6; padding: 1rem 1.25rem;
            border-radius: 0 8px 8px 0; margin: 1rem 0;
        }
        .finding.positive { background: #f0fdf4; border-color: #10b981; }
        .finding.neutral { background: #fefce8; border-color: #eab308; }

        .legend { display: flex; gap: 1.5rem; margin: 1rem 0; flex-wrap: wrap; }
        .legend-item { display: flex; align-items: center; gap: 0.5rem; font-size: 0.9rem; }
        .legend-dot { width: 12px; height: 12px; border-radius: 50%; }

        @media (max-width: 768px) {
            .chart-grid { grid-template-columns: 1fr; }
            .summary-grid { grid-template-columns: 1fr 1fr; }
            body { padding: 1rem; }
        }

        @media print {
            body { background: white; }
            .card, .chart-container { box-shadow: none; border: 1px solid #ccc; }
            .chart-container { break-inside: avoid; }
        }
    </style>
</head>
<body>
<div class="container">
    <h1>QuarkGate Performance Benchmark Report</h1>
    <p class="subtitle">GraphQL Gateway Aggregation vs REST Waterfall Pattern</p>
    <p class="timestamp">Generated: 2026-02-16 09:12:17 UTC
    | REST test: 2026-02-16T08:55:24.841Z
    | GraphQL test: 2026-02-16T08:59:48.608Z</p>

    <!-- ── Executive Summary ─────────────────────────────── -->
    <h2>1. Executive Summary</h2>
    <div class="summary-grid">
        <div class="card">
            <div class="card-label">REST Avg Latency</div>
            <div class="card-value rest">10.32 ms</div>
            <div class="card-detail">p95: 18.00 ms | max: 629.00 ms</div>
        </div>
        <div class="card">
            <div class="card-label">GraphQL Avg Latency</div>
            <div class="card-value graphql">7.24 ms</div>
            <div class="card-detail">p95: 13.00 ms | max: 259.00 ms</div>
        </div>
        <div class="card">
            <div class="card-label">REST HTTP Calls / Iteration</div>
            <div class="card-value rest">113534</div>
            <div class="card-detail">Total calls: 113534 | Rate: 781.42/s</div>
        </div>
        <div class="card">
            <div class="card-label">GraphQL HTTP Calls / Iteration</div>
            <div class="card-value graphql">1</div>
            <div class="card-detail">Total requests: 21431 | Rate: 147.49/s</div>
        </div>
        
        <div class="card">
            <div class="card-label">Avg Latency Improvement</div>
            <div class="card-value improvement">-29.9%</div>
            <div class="card-detail">GraphQL gateway aggregation vs REST waterfall</div>
        </div>
        
        
        <div class="card">
            <div class="card-label">Avg Payload Size</div>
            <div class="card-value improvement">+1.2%</div>
            <div class="card-detail">REST: 695B vs GraphQL: 703B</div>
        </div>
        
    </div>

    <!-- ── Key Findings ──────────────────────────────────── -->
    <h3>Key Findings</h3>
    
    <div class="finding positive">
        <strong>Latency:</strong> GraphQL gateway averages <strong>7.24ms</strong> vs REST waterfall at <strong>10.32ms</strong>.
        GraphQL is <strong>-29.9%</strong> faster due to parallel internal scatter-gather.
    </div>
    <div class="finding positive">
        <strong>Network Efficiency:</strong> REST requires <strong>5-9 sequential HTTP round-trips</strong> per user while GraphQL requires exactly <strong>1 request</strong>.
        Under high-latency conditions (mobile, global distribution), this reduction is significant.
    </div>
    
    <div class="finding neutral">
        <strong>Payload Size:</strong> REST transfers an average of <strong>695 bytes</strong> vs GraphQL at <strong>703 bytes</strong>.
        GraphQL's field-level selection eliminates over-fetching.
    </div>

    <!-- ── Latency Comparison Chart ──────────────────────── -->
    <h2>2. Latency Analysis</h2>
    <div class="chart-grid">
        <div class="chart-container">
            <div class="chart-title">Average Latency Comparison (ms)</div>
            <canvas id="latencyAvgChart"></canvas>
        </div>
        <div class="chart-container">
            <div class="chart-title">Latency Percentiles (ms)</div>
            <canvas id="latencyPercentilesChart"></canvas>
        </div>
    </div>

    <!-- ── Detailed metrics table ────────────────────────── -->
    <h3>Detailed Latency Metrics</h3>
    <div class="card">
    <table>
        <thead>
            <tr><th>Metric</th><th>Min</th><th>Avg</th><th>Median</th><th>p90</th><th>p95</th><th>Max</th></tr>
        </thead>
        <tbody>
            
            <tr>
                <td><strong class="val-rest">REST Waterfall (total)</strong></td>
                <td>3.00</td><td>10.32</td><td>8.00</td>
                <td>15.00</td><td>18.00</td><td>629.00</td>
            </tr>
            
            <tr>
                <td><strong class="val-gql">GraphQL Aggregated</strong></td>
                <td>1.00</td><td>7.24</td><td>6.00</td>
                <td>10.00</td><td>13.00</td><td>259.00</td>
            </tr>
            
            <tr>
                <td>&nbsp;&nbsp;REST: GET /users/:id</td>
                <td>0.00</td><td>2.10</td>
                <td>1.57</td><td>2.68</td>
                <td>3.37</td><td>323.71</td>
            </tr>
            
            <tr>
                <td>&nbsp;&nbsp;REST: GET /orders/user/:id</td>
                <td>0.00</td><td>1.95</td>
                <td>1.59</td><td>2.68</td>
                <td>3.35</td><td>350.28</td>
            </tr>
            
            <tr>
                <td>&nbsp;&nbsp;REST: GET /products/:id (scatter)</td>
                <td>0.00</td><td>2.68</td>
                <td>2.00</td><td>4.00</td>
                <td>5.00</td><td>114.00</td>
            </tr>
            
            <tr>
                <td>&nbsp;&nbsp;REST: GET /payments/order/:id</td>
                <td>0.00</td><td>1.75</td>
                <td>1.57</td><td>2.61</td>
                <td>3.19</td><td>93.11</td>
            </tr>
        </tbody>
    </table>
    </div>

    <!-- ── Payload & Network ─────────────────────────────── -->
    <h2>3. Network Efficiency</h2>
    <div class="chart-grid">
        <div class="chart-container">
            <div class="chart-title">HTTP Round Trips per User Query</div>
            <canvas id="httpCallsChart"></canvas>
        </div>
        <div class="chart-container">
            <div class="chart-title">Payload Size (bytes)</div>
            <canvas id="payloadChart"></canvas>
        </div>
    </div>

    <!-- ── Throughput ────────────────────────────────────── -->
    <h2>4. Throughput Analysis</h2>
    <div class="chart-grid">
        <div class="chart-container">
            <div class="chart-title">Requests per Second</div>
            <canvas id="throughputChart"></canvas>
        </div>
        <div class="chart-container">
            <div class="chart-title">Total Requests Completed</div>
            <canvas id="totalRequestsChart"></canvas>
        </div>
    </div>

    <!-- ── Cache Impact ──────────────────────────────────── -->
    
    <h2>5. Redis Cache Impact</h2>
    <div class="chart-grid">
        <div class="chart-container">
            <div class="chart-title">Cold Cache vs Warm Cache Latency (ms)</div>
            <canvas id="cacheChart"></canvas>
        </div>
        <div class="chart-container">
            <div class="chart-title">Cache Performance Summary</div>
            <canvas id="cacheBarChart"></canvas>
        </div>
    </div>
    <div class="card">
    <table>
        <thead><tr><th>Phase</th><th>Min</th><th>Avg</th><th>Median</th><th>p90</th><th>p95</th><th>Max</th></tr></thead>
        <tbody>
            
            <tr>
                <td><strong class="val-rest">Cold Cache</strong></td>
                <td>2.00</td><td>15.99</td>
                <td>14.00</td><td>28.20</td>
                <td>56.00</td><td>64.00</td>
            </tr>
            
            <tr>
                <td><strong class="val-gql">Warm Cache</strong></td>
                <td>0.00</td><td>10.99</td>
                <td>7.00</td><td>17.00</td>
                <td>37.00</td><td>130.00</td>
            </tr>
        </tbody>
    </table>
    </div>
    
    <div class="finding positive">
        <strong>Cache Improvement:</strong> Redis caching reduced average response time from
        <strong>15.99ms</strong> (cold) to <strong>10.99ms</strong> (warm),
        a <strong>-31.3%</strong> improvement.
    </div>
    

    <!-- ── Comparison (side-by-side) ─────────────────────── -->
    
    <h2>6. Side-by-Side Comparison (Simultaneous Load)</h2>
    <div class="chart-grid">
        <div class="chart-container full-width">
            <div class="chart-title">REST vs GraphQL Under Identical Load Conditions</div>
            <canvas id="comparisonChart"></canvas>
        </div>
    </div>
    <div class="card">
    <table>
        <thead><tr><th>Metric</th><th class="val-rest">REST</th><th class="val-gql">GraphQL</th><th>Improvement</th></tr></thead>
        <tbody>
            
            <tr>
                <td>Avg Latency</td>
                <td class="val-rest">11.41 ms</td>
                <td class="val-gql">8.72 ms</td>
                <td class="val-good">-23.6%</td>
            </tr>
            <tr>
                <td>p95 Latency</td>
                <td class="val-rest">20.00 ms</td>
                <td class="val-gql">15.00 ms</td>
                <td class="val-good">-25.0%</td>
            </tr>
            
            <tr>
                <td>Avg Payload Size</td>
                <td class="val-rest">693 B</td>
                <td class="val-gql">696 B</td>
                <td class="val-good">+0.5%</td>
            </tr>
            
            <tr>
                <td>Total HTTP Calls</td>
                <td class="val-rest">50139</td>
                <td class="val-gql">9510</td>
                <td class="val-good">-81.0%</td>
            </tr>
            
            <tr>
                <td>Error Rate</td>
                <td class="val-rest">0.00%</td>
                <td class="val-gql">0.00%</td>
                <td>-</td>
            </tr>
        </tbody>
    </table>
    </div>
    

    <!-- ── Methodology ───────────────────────────────────── -->
    <h2>7. Test Methodology</h2>
    <div class="card" style="padding: 2rem;">
        <h3 style="margin-top: 0;">Test Environment</h3>
        <table>
            <tr><td><strong>Architecture</strong></td><td>QuarkGate — Quarkus 3.17.2 microservices with GraphQL gateway</td></tr>
            <tr><td><strong>Services</strong></td><td>User, Product, Order, Payment (each with dedicated PostgreSQL)</td></tr>
            <tr><td><strong>Gateway</strong></td><td>SmallRye GraphQL + Redis cache (60s/120s TTL) + Fault Tolerance</td></tr>
            <tr><td><strong>Infrastructure</strong></td><td>Docker Compose: 4 PostgreSQL, Redis 7, Kafka (Confluent 7.5), Keycloak 23, Jaeger 1.62</td></tr>
            <tr><td><strong>Load Tool</strong></td><td>Grafana k6</td></tr>
        </table>

        <h3>Load Scenarios</h3>
        <table>
            <thead><tr><th>Scenario</th><th>Virtual Users</th><th>Duration</th><th>Purpose</th></tr></thead>
            <tbody>
                <tr><td>Baseline</td><td>10 VUs</td><td>30s</td><td>Establish baseline latency</td></tr>
                <tr><td>Moderate</td><td>50 VUs</td><td>30s</td><td>Typical production load</td></tr>
                <tr><td>Stress</td><td>100 VUs</td><td>30s</td><td>High load behavior</td></tr>
                <tr><td>Spike</td><td>0 &rarr; 200 &rarr; 0</td><td>40s</td><td>Burst traffic resilience</td></tr>
            </tbody>
        </table>

        <h3>REST Waterfall Pattern (Control)</h3>
        <p>Simulates the traditional N+1 problem: sequential HTTP calls from client to each microservice.</p>
        <pre style="background: #f1f5f9; padding: 1rem; border-radius: 8px; overflow-x: auto; margin: 0.5rem 0;">
GET /users/1                    → User-Service     (1 call)
GET /orders/user/1              → Order-Service    (1 call)
GET /products/1                 → Product-Service  (N calls)
GET /products/2                 → Product-Service
GET /payments/order/1           → Payment-Service  (N calls)
GET /payments/order/2           → Payment-Service
                                  Total: 5-9+ HTTP round trips</pre>

        <h3>GraphQL Gateway Pattern (Treatment)</h3>
        <p>Single GraphQL query; gateway performs scatter-gather internally with parallel resolution.</p>
        <pre style="background: #f1f5f9; padding: 1rem; border-radius: 8px; overflow-x: auto; margin: 0.5rem 0;">
POST /graphql {
  user(id: 1) {
    orders { products, payment }
  }
}
→ Gateway internally fans out to all 4 services in parallel
← Single JSON response
                                  Total: 1 HTTP round trip</pre>
    </div>

    <!-- ── Footer ────────────────────────────────────────── -->
    <div style="text-align: center; margin: 3rem 0 1rem; color: #94a3b8; font-size: 0.85rem;">
        QuarkGate Benchmark Report | M.Tech Thesis — GraphQL Gateway Aggregation Pattern for Microservices
    </div>
</div>

<script>
    const COLORS = {
        rest: { bg: 'rgba(239, 68, 68, 0.15)', border: '#ef4444' },
        graphql: { bg: 'rgba(59, 130, 246, 0.15)', border: '#3b82f6' },
        improvement: { bg: 'rgba(16, 185, 129, 0.15)', border: '#10b981' },
        cold: { bg: 'rgba(249, 115, 22, 0.15)', border: '#f97316' },
        warm: { bg: 'rgba(16, 185, 129, 0.15)', border: '#10b981' },
        mixed: { bg: 'rgba(168, 85, 247, 0.15)', border: '#a855f7' },
    };

    const defaultOptions = {
        responsive: true,
        plugins: { legend: { position: 'bottom' } },
    };

    // ── Chart 1: Average Latency ─────────────────────────
    
    new Chart(document.getElementById('latencyAvgChart'), {
        type: 'bar',
        data: {
            labels: ['Average', 'Median', 'Min', 'Max'],
            datasets: [
                {
                    label: 'REST Waterfall',
                    data: [10.321348209263078, 8, 3, 629],
                    backgroundColor: COLORS.rest.bg, borderColor: COLORS.rest.border, borderWidth: 2,
                },
                {
                    label: 'GraphQL Aggregated',
                    data: [7.236619849750362, 6, 1, 259],
                    backgroundColor: COLORS.graphql.bg, borderColor: COLORS.graphql.border, borderWidth: 2,
                },
            ],
        },
        options: { ...defaultOptions, scales: { y: { title: { display: true, text: 'Milliseconds' } } } },
    });

    // ── Chart 2: Latency Percentiles ─────────────────────
    
    new Chart(document.getElementById('latencyPercentilesChart'), {
        type: 'line',
        data: {
            labels: ['Min', 'p50 (Median)', 'p90', 'p95', 'Max'],
            datasets: [
                {
                    label: 'REST Waterfall',
                    data: [3, 8, 15, 18, 629],
                    borderColor: COLORS.rest.border, backgroundColor: COLORS.rest.bg, fill: true, tension: 0.3,
                },
                {
                    label: 'GraphQL Aggregated',
                    data: [1, 6, 10, 13, 259],
                    borderColor: COLORS.graphql.border, backgroundColor: COLORS.graphql.bg, fill: true, tension: 0.3,
                },
            ],
        },
        options: { ...defaultOptions, scales: { y: { title: { display: true, text: 'Milliseconds' } } } },
    });

    // ── Chart 3: HTTP Calls ──────────────────────────────
    new Chart(document.getElementById('httpCallsChart'), {
        type: 'doughnut',
        data: {
            labels: ['REST (5-9 calls)', 'GraphQL (1 call)'],
            datasets: [{
                data: [7, 1],
                backgroundColor: [COLORS.rest.bg, COLORS.graphql.bg],
                borderColor: [COLORS.rest.border, COLORS.graphql.border],
                borderWidth: 2,
            }],
        },
        options: defaultOptions,
    });

    // ── Chart 4: Payload Size ────────────────────────────
    
    new Chart(document.getElementById('payloadChart'), {
        type: 'bar',
        data: {
            labels: ['Average', 'Min', 'Max'],
            datasets: [
                {
                    label: 'REST Waterfall',
                    data: [694.7957059816239, 463, 1019],
                    backgroundColor: COLORS.rest.bg, borderColor: COLORS.rest.border, borderWidth: 2,
                },
                {
                    label: 'GraphQL Aggregated',
                    data: [702.857589473193, 465, 1028],
                    backgroundColor: COLORS.graphql.bg, borderColor: COLORS.graphql.border, borderWidth: 2,
                },
            ],
        },
        options: { ...defaultOptions, scales: { y: { title: { display: true, text: 'Bytes' } } } },
    });

    // ── Chart 5: Throughput ──────────────────────────────
    
    new Chart(document.getElementById('throughputChart'), {
        type: 'bar',
        data: {
            labels: ['Requests per Second'],
            datasets: [
                {
                    label: 'REST Waterfall',
                    data: [781.4180927688528],
                    backgroundColor: COLORS.rest.bg, borderColor: COLORS.rest.border, borderWidth: 2,
                },
                {
                    label: 'GraphQL Aggregated',
                    data: [147.49427945216215],
                    backgroundColor: COLORS.graphql.bg, borderColor: COLORS.graphql.border, borderWidth: 2,
                },
            ],
        },
        options: { ...defaultOptions, scales: { y: { title: { display: true, text: 'req/s' } } } },
    });
    new Chart(document.getElementById('totalRequestsChart'), {
        type: 'bar',
        data: {
            labels: ['Total Requests Completed'],
            datasets: [
                {
                    label: 'REST Waterfall',
                    data: [113534],
                    backgroundColor: COLORS.rest.bg, borderColor: COLORS.rest.border, borderWidth: 2,
                },
                {
                    label: 'GraphQL Aggregated',
                    data: [21431],
                    backgroundColor: COLORS.graphql.bg, borderColor: COLORS.graphql.border, borderWidth: 2,
                },
            ],
        },
        options: defaultOptions,
    });

    // ── Chart 6: Cache Impact ────────────────────────────
    
    new Chart(document.getElementById('cacheChart'), {
        type: 'line',
        data: {
            labels: ['Min', 'p50', 'p90', 'p95', 'Max'],
            datasets: [
                {
                    label: 'Cold Cache',
                    data: [2, 14, 28.19999999999999, 56, 64],
                    borderColor: COLORS.cold.border, backgroundColor: COLORS.cold.bg, fill: true, tension: 0.3,
                },
                {
                    label: 'Warm Cache',
                    data: [0, 7, 17, 37, 130],
                    borderColor: COLORS.warm.border, backgroundColor: COLORS.warm.bg, fill: true, tension: 0.3,
                },
            ],
        },
        options: { ...defaultOptions, scales: { y: { title: { display: true, text: 'Milliseconds' } } } },
    });
    new Chart(document.getElementById('cacheBarChart'), {
        type: 'bar',
        data: {
            labels: ['Average', 'Median', 'p95'],
            datasets: [
                {
                    label: 'Cold Cache',
                    data: [15.986666666666666, 14, 56],
                    backgroundColor: COLORS.cold.bg, borderColor: COLORS.cold.border, borderWidth: 2,
                },
                {
                    label: 'Warm Cache',
                    data: [10.985053267610112, 7, 37],
                    backgroundColor: COLORS.warm.bg, borderColor: COLORS.warm.border, borderWidth: 2,
                },
            ],
        },
        options: { ...defaultOptions, scales: { y: { title: { display: true, text: 'Milliseconds' } } } },
    });

    // ── Chart 7: Comparison ──────────────────────────────
    
    new Chart(document.getElementById('comparisonChart'), {
        type: 'bar',
        data: {
            labels: ['Average Latency (ms)', 'Median Latency (ms)', 'p95 Latency (ms)', 'Max Latency (ms)'],
            datasets: [
                {
                    label: 'REST Waterfall',
                    data: [
                        11.409745762711864, 8,
                        20, 219
                    ],
                    backgroundColor: COLORS.rest.bg, borderColor: COLORS.rest.border, borderWidth: 2,
                },
                {
                    label: 'GraphQL Aggregated',
                    data: [
                        8.720820189274448, 6,
                        15, 226
                    ],
                    backgroundColor: COLORS.graphql.bg, borderColor: COLORS.graphql.border, borderWidth: 2,
                },
            ],
        },
        options: { ...defaultOptions, scales: { y: { title: { display: true, text: 'Milliseconds' } } } },
    });
</script>
</body>
</html>